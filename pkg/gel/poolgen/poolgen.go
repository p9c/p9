package main

import (
	"os"
)

type poolType struct {
	name, sliceName, constructor string
}

var types = []poolType{
	{"Bool", "bools", "Bool(false)"},
	{"List", "lists", "List()"},
	{"Checkable", "checkables", "Checkable()"},
	{"Clickable", "clickables", "Clickable()"},
	{"Editor", "editors", "Editor()"},
	{"IncDec", "incDecs", "IncDec()"},
	// {"Stack", "stacks", "Stack()"},
}

func main() {
	var out string
	out += `// generated by go run github.com/p9c/p9/pkg/gel/poolgen/poolgen.go; DO NOT EDIT
//
`+`//go:generate go run ./poolgen/.

package gel
`
	for i := range types {
		out += `
func (p *Pool) Get` + types[i].name + `() (out *` + types[i].name + `) {
	if len(p.` + types[i].sliceName + `) >= p.` + types[i].sliceName + `InUse {
		for i := 0; i < 10; i++ {
			p.` + types[i].sliceName + ` = append(p.` + types[i].sliceName + `, p.` + types[i].constructor + `)
		}
	}
	out = p.` + types[i].sliceName + `[p.` + types[i].sliceName + `InUse]
	p.` + types[i].sliceName + `InUse++
	return
}

func (p *Pool) Free` + types[i].name + `(b *` + types[i].name + `) {
	for i := 0; i < p.` + types[i].sliceName + `InUse; i++ {
		if p.` + types[i].sliceName + `[i] == b {
			if i != p.` + types[i].sliceName + `InUse-1 {
				// move the item to the end. the next allocation will be then at index p.` + types[i].sliceName + `InUse
				tmp := p.` + types[i].sliceName + `[i]
				p.` + types[i].sliceName + ` = append(p.` + types[i].sliceName + `[:i], p.` + types[i].sliceName + `[i+1:]...)
				p.` + types[i].sliceName + ` = append(p.` + types[i].sliceName + `, tmp)
				p.` + types[i].sliceName + `InUse--
				break
			}
		}
	}
}

`
	}
	if fd, e := os.Create("pooltypes.go"); E.Chk(e) {
	} else {
		defer func() {
			if e = fd.Close(); E.Chk(e) {
			}
		}()
		
		if _, e = fd.Write([]byte(out)); E.Chk(e) {
		}
	}
}
