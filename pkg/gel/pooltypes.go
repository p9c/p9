// generated by go run github.com/p9c/p9/pkg/gel/poolgen/poolgen.go; DO NOT EDIT
//
//go:generate go run ./poolgen/.

package gel

func (p *Pool) GetBool() (out *Bool) {
	if len(p.bools) >= p.boolsInUse {
		for i := 0; i < 10; i++ {
			p.bools = append(p.bools, p.Bool(false))
		}
	}
	out = p.bools[p.boolsInUse]
	p.boolsInUse++
	return
}

func (p *Pool) FreeBool(b *Bool) {
	for i := 0; i < p.boolsInUse; i++ {
		if p.bools[i] == b {
			if i != p.boolsInUse-1 {
				// move the item to the end. the next allocation will be then at index p.boolsInUse
				tmp := p.bools[i]
				p.bools = append(p.bools[:i], p.bools[i+1:]...)
				p.bools = append(p.bools, tmp)
				p.boolsInUse--
				break
			}
		}
	}
}


func (p *Pool) GetList() (out *List) {
	if len(p.lists) >= p.listsInUse {
		for i := 0; i < 10; i++ {
			p.lists = append(p.lists, p.List())
		}
	}
	out = p.lists[p.listsInUse]
	p.listsInUse++
	return
}

func (p *Pool) FreeList(b *List) {
	for i := 0; i < p.listsInUse; i++ {
		if p.lists[i] == b {
			if i != p.listsInUse-1 {
				// move the item to the end. the next allocation will be then at index p.listsInUse
				tmp := p.lists[i]
				p.lists = append(p.lists[:i], p.lists[i+1:]...)
				p.lists = append(p.lists, tmp)
				p.listsInUse--
				break
			}
		}
	}
}


func (p *Pool) GetCheckable() (out *Checkable) {
	if len(p.checkables) >= p.checkablesInUse {
		for i := 0; i < 10; i++ {
			p.checkables = append(p.checkables, p.Checkable())
		}
	}
	out = p.checkables[p.checkablesInUse]
	p.checkablesInUse++
	return
}

func (p *Pool) FreeCheckable(b *Checkable) {
	for i := 0; i < p.checkablesInUse; i++ {
		if p.checkables[i] == b {
			if i != p.checkablesInUse-1 {
				// move the item to the end. the next allocation will be then at index p.checkablesInUse
				tmp := p.checkables[i]
				p.checkables = append(p.checkables[:i], p.checkables[i+1:]...)
				p.checkables = append(p.checkables, tmp)
				p.checkablesInUse--
				break
			}
		}
	}
}


func (p *Pool) GetClickable() (out *Clickable) {
	if len(p.clickables) >= p.clickablesInUse {
		for i := 0; i < 10; i++ {
			p.clickables = append(p.clickables, p.Clickable())
		}
	}
	out = p.clickables[p.clickablesInUse]
	p.clickablesInUse++
	return
}

func (p *Pool) FreeClickable(b *Clickable) {
	for i := 0; i < p.clickablesInUse; i++ {
		if p.clickables[i] == b {
			if i != p.clickablesInUse-1 {
				// move the item to the end. the next allocation will be then at index p.clickablesInUse
				tmp := p.clickables[i]
				p.clickables = append(p.clickables[:i], p.clickables[i+1:]...)
				p.clickables = append(p.clickables, tmp)
				p.clickablesInUse--
				break
			}
		}
	}
}


func (p *Pool) GetEditor() (out *Editor) {
	if len(p.editors) >= p.editorsInUse {
		for i := 0; i < 10; i++ {
			p.editors = append(p.editors, p.Editor())
		}
	}
	out = p.editors[p.editorsInUse]
	p.editorsInUse++
	return
}

func (p *Pool) FreeEditor(b *Editor) {
	for i := 0; i < p.editorsInUse; i++ {
		if p.editors[i] == b {
			if i != p.editorsInUse-1 {
				// move the item to the end. the next allocation will be then at index p.editorsInUse
				tmp := p.editors[i]
				p.editors = append(p.editors[:i], p.editors[i+1:]...)
				p.editors = append(p.editors, tmp)
				p.editorsInUse--
				break
			}
		}
	}
}


func (p *Pool) GetIncDec() (out *IncDec) {
	if len(p.incDecs) >= p.incDecsInUse {
		for i := 0; i < 10; i++ {
			p.incDecs = append(p.incDecs, p.IncDec())
		}
	}
	out = p.incDecs[p.incDecsInUse]
	p.incDecsInUse++
	return
}

func (p *Pool) FreeIncDec(b *IncDec) {
	for i := 0; i < p.incDecsInUse; i++ {
		if p.incDecs[i] == b {
			if i != p.incDecsInUse-1 {
				// move the item to the end. the next allocation will be then at index p.incDecsInUse
				tmp := p.incDecs[i]
				p.incDecs = append(p.incDecs[:i], p.incDecs[i+1:]...)
				p.incDecs = append(p.incDecs, tmp)
				p.incDecsInUse--
				break
			}
		}
	}
}

